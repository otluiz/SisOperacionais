\documentclass[11pt]{beamer}
\usetheme{Warsaw}
\usepackage[utf8]{inputenc}
\usepackage[brazil]{babel}  % idioma
\usepackage{amsmath,amsfonts,amssymb,textcomp}
\usepackage{graphicx}
\usepackage{subfigure}

\usepackage[lined]{algorithm2e}

% Configurando layout para mostrar codigos C++
\usepackage{listings}
%\usepackage{minted}
%pdflatex -shell-escape minted01.tex
%ou
%latexmk -pdf -shell-escape minted01.tex

\author{Othon Oliveira}
\title{Sistemas Operacionais}
%\setbeamercovered{transparent} 
%\setbeamertemplate{navigation symbols}{} 
%\logo{} 
\institute{Fatec -- Faculdade de Informática --- PE} 
%\date{} 
%\subject{} 
\begin{document}


% Capa - requer o TikZ
\newcommand{\capa}{
    \begin{tikzpicture}[remember picture,overlay]
        \node at (current page.south west)
            {\begin{tikzpicture}[remember picture, overlay]
                \fill[shading=radial,top color=orange,bottom color=orange,middle color=yellow] (0,0) rectangle (\paperwidth,\paperheight);
            \end{tikzpicture}
          };
    \end{tikzpicture}
}




\begin{frame}
\titlepage
\end{frame}

\begin{frame}
\tableofcontents
\end{frame}



%+++++++++++++++++++++++++++++++++++++++++++++++
\section{Comunicação entre processos}
\subsection*{Comparação com a Solução de Paterson}

\begin{frame}{Espera ociosa}
 A Solução de Paterson com base na \textbf{TSL} está correta, mas ambas apresentam o defeito da \textbf{espera ociosa}
 
\pause
 \begin{block}{A essência}
  Em essência o que as instruções fazem é: quando quer entrar em sua região crítica um processo verifica se sua entrada é permitida.
  Se não for, o processo ficará em um loop ocioso esperando até que seja permitida a entrada.
 \end{block}
 
 \pause
 Qual o problema dessa solução?
 \pause
 \begin{block}{CPU}
  Não só gasta tempo da CPU como pode, pode gerar outro problema.
 \end{block}

\end{frame}


%+++++++++++++++++++++++++++++++++++++++++++++++
\begin{frame}\frametitle{A Inversão de prioridade}

\begin{block}{ As prioridades podem se inverter?}
Considere um computador com dois processos: \textit{H}, com alta prioridade, e \textit{L}, com baixa prioridade. As regras de escalonamento são tais que \textit{H} é 
executado sempre que estiver no estado pronto. Em certo momento, com \textit{L} em sua região crítica, \textit{H} torna-se pronto para execuar (ex: terminou uma E/S).
\end{block}

\pause
\begin{block}{O loop infinito}
 Agora \textit{H} inicia uma espera ociosa, como \textit{L} nunca é escalonado enquanto \textit{H} está executando, \textit{L} nunca tem a oportunidade de deixar sua região 
 crítica e, assim \textit{H} entra em um laço infinito. Essa situação é chamada de \textbf{problema da inversão de prioridade}.
\end{block}
\end{frame}


%+++++++++++++++++++++++++++++++++++++++++++++++
\subsection*{ As diretivas ``Dormir'' ou ``Acordar''}
\begin{frame}\frametitle{``Sleep'' ou ``Wakeup''}

\begin{block}{O bloqueio em vez da Espera Ociosa}
Quando não é permitido a um processo não entrar em sua região crítica, ele pode ser posta a dormir.
Com o par de intruções \textbf{sleep} e \textbf{wakeup}.
\end{block}

\pause
\begin{block}{ Sleep}
 Sleep é uma chamada ao sistema que faz com que quem a chama durma, isto é, fica suspenso até que outro processo o desperte.
\end{block}

\pause
\begin{block}{ Wakeup}
 Wakeup tem um parâmetro, qual processo a ser despertado e outro parâmetro um endereço de memória usado para comparar wakeups e seus respectivos sleeps.
\end{block}
\end{frame}


%+++++++++++++++++++++++++++++++++++++++++++++++
\section{O problema produtor -- consumidor}
\subsection*{Produzindo e consumindo}

\begin{frame}{Buffer limitado}
 
 \begin{block}{ Compartilhando buffer}
 Dois processos compartilham um buffer comum de tamanho fixo. 
 \pause
 Um deles o \textbf{produtor}, põe informação dentro do buffer e o outro,
 \pause
 o \textbf{consumidor} a retira informações desse buffer.
 \end{block}
 \pause
 É possível generalizar para M produtores e N consumidores.
\end{frame}

%------------------------------------------------------------------

\begin{frame}{ A solução: produtor -- consumidor}

\begin{block}{ Quando produzir?}
 O produtor quer colocar um novo item em um buffer cheio ?
 \end{block}

 \pause
\begin{block}{ Quando consumir?}
 Ou o consumidor quer retirar de um buffer vazio ?
\end{block}

\pause
 A solução: uma varável \textit{count}, os processos verificam essa variável antes de consumir ou produzir
\end{frame}

%+++++++++++++++++++++++++++++++++++++++++++++++
\subsection*{O algoritmo produtor -- consumidor}

\begin{frame}{ O produtor}
  \begin{algorithm}[H]
    \#Define N 100	/* número lugares no buffer */ \\
    int count = 0;	/* número de itens no buffer */ \\
    
    void producer(void)\{ \\
      int item;\\
      
      enquanto(verdadeiro)\{\\
	item = produzirItem(); /* gera o próximo item */\\ 
	se (count == N) sleep();/* se o buffer estiver cheio vá dormir */\\
	  inserirItem(item)	/* ponha um item no buffer */\\
	count = count + 1;       /* incrementa o contador de itens */\\
	se (count == 1) 	 /* o buffer está vazio? */\\
	  wakeup(consumer());	 /* acorda e chama consumer */\\
    \}\\
  \end{algorithm}
\end{frame}

%------------------------------------------------------------

\begin{frame}{ O consumidor}
  \begin{algorithm}[H]
    
    void consumer(void)\{ \\
      int intem; \\
      
      enquanto(verdadeiro)\{\\
	se (count == 0) sleep();/* se o buffer estiver vazio vá dormir */\\
	item = removeItem(); 	/* retire um item do buffer */\\
	count = count - 1;      /* decrementa o contador de itens */\\
	se (count == N-1) 	/* o buffer está cheio ? */\\
	  wakeup(producer());	/* acorda e produz */\\
	consumirItem(item);	/* imprima o item */\\
    \}\\
  \end{algorithm}
  \pause
  Qual o problema do algoritmo consumidor -- produtor ??
\end{frame}

%------------------------------------------------------------------

\begin{frame}{ Um problema na solução produtor -- consumidor}

\begin{block}{ O problema do acesso irrestrito da variável \textit{count}}
  O buffer está vazio e o consumidor acabou de ler a variável \textit{count} para verificar se seu valor é 0.
  \pause
  O escalonador decide parar de executar o consumidor temporariamente e começa a executar o produtor.
 \end{block}

 \pause
\begin{block}{ E o produtor}
 O produtor faz inserirItem(item) e incrementa \textit{count} e percebe que seu valor agora é 1, inferindo que o valor era 0.
 \pause
 Ou seja o consumidor deveria ir dormir, o produtor chama \textit{wakeup} para acordar o consumidor.
\end{block}
\pause
 Infelizmente, o consumidor ainda não está adormecido; então, o sinal de acordar é perdido.
\end{frame}

%------------------------------------------------------------------

\begin{frame}{ Uma solução para o sinal perdido}

\begin{block}{ A essência é não perder um sinal de acordar  para um processo que (ainda) não adormeceu.}
  O buffer está vazio e o consumidor acabou de ler a variável \textit{count} para verificar se seu valor é 0.
  \pause
  Se esse sinal não fosse perdido tudo funcionaria, em suma adicionar um controle que um \textbf{bit de espera de sinal de acordar}
 \end{block}

 \pause
\begin{block}{ Um bit de acorda}
 Quando um sinal de ``acordar'' for enviado a um processo que ainda não está acordado, esse sinal acionaria um bit \textbf{ligado}
 \pause
 Depois, quando o processo tentar dormir, se o bit de espera pelo sinal de acordar estiver ligado, ele será desligado.
\end{block}
\pause
 O bit de espera de sinal de acordar na verdade é um ``cofrinho'' que guarda sinais de acordar.
\end{frame}

\end{document}