\documentclass[11pt]{beamer}
\usetheme{Warsaw}
\usepackage[utf8]{inputenc}
\usepackage[brazil]{babel}  % idioma
\usepackage{amsmath,amsfonts,amssymb,textcomp}
\usepackage{graphicx}
\usepackage{subfigure}

\usepackage[lined]{algorithm2e}

% Configurando layout para mostrar codigos C++
\usepackage{listings}
%\usepackage{minted}
%pdflatex -shell-escape minted01.tex
%ou
%latexmk -pdf -shell-escape minted01.tex

\author{Othon Oliveira}
\title{Sistemas Operacionais}
%\setbeamercovered{transparent} 
%\setbeamertemplate{navigation symbols}{} 
%\logo{} 
\institute{Fatec -- Faculdade de Informática --- PE} 
%\date{} 
%\subject{} 
\begin{document}


% Capa - requer o TikZ
\newcommand{\capa}{
    \begin{tikzpicture}[remember picture,overlay]
        \node at (current page.south west)
            {\begin{tikzpicture}[remember picture, overlay]
                \fill[shading=radial,top color=orange,bottom color=orange,middle color=yellow] (0,0) rectangle (\paperwidth,\paperheight);
            \end{tikzpicture}
          };
    \end{tikzpicture}
}




\begin{frame}
\titlepage
\end{frame}

%+++++++++++++++++++++++++++++++++++++++++++++++
\begin{frame}{Monitores -- Monitores}
\begin{figure}[h]
%\left
\includegraphics[width=18mm, height=15mm]{Figuras/appleOficial.jpg}
\qquad \quad \quad \quad \quad
\includegraphics[width=19mm, height=17mm]{Figuras/windows.png}
\qquad \quad \quad \quad \quad \quad \quad 	\vspace{1.0in}
\includegraphics[width=15mm, height=15mm]{Figuras/android.jpg}
\qquad \quad \quad \quad \quad \quad \quad \quad 
\includegraphics[width=25mm, height=15mm]{Figuras/ubuntu_904.jpg}

\end{figure}
\end{frame}


\begin{frame}
\tableofcontents
\end{frame}


%+++++++++++++++++++++++++++++++++++++++++++++++
\section{ Semáforos}
\subsection*{ Deadlock}

\begin{frame}\frametitle{ Semáforos fora de ordem}
 Suponha que os dois ``downs'' no código do produtor, estivessem invertidos:\\
\pause

\transblindshorizontal[duration=2, direction=25]
 \begin{algorithm}[H]    
void producer(void)\{ \\
\hspace{0,2 cm}      while(true)\{	/* True é a constante 1 */\\
\hspace{0,5 cm}	item = produzirItem(); 	/* gera o próximo item */\\ 
\hspace{0,5 cm}	\textbf{down(\&empty)};	/* decresce o contador de empty */\\
\hspace{0,5 cm}	\textbf{down(\&mutex)};	/* entra na região crítica */\\
\hspace{0,5 cm}	inserirItem(item);	/* ponha um item no buffer */\\
\hspace{0,5 cm}	up(\&mutex);	 	/* o buffer está vazio? */\\
\hspace{0,5 cm}	up(\&full);		/* incrementa o contador de lugares preenchidos */\\
\hspace{0,2 cm}      \}\\
\end{algorithm}
 
\end{frame}


%--------------------------------------------------------
\begin{frame}\frametitle{ Erros comuns -- inversão de ordem}

\begin{block}{ Operações de semáforos}
  Invertidos de modo que o mutex seria decrescido antes do ``empty'', em vez de depois.
\end{block}


\pause
\begin{exampleblock}{ Como fica o buffer?}
  Se o buffer estivesse completamente cheio, o que aconteceria com o produtor?
\end{exampleblock}

\pause
  O produtor seria bloqueado quando o mutex chegasse a 0 (zero)

\end{frame}


%--------------------------------------------------------
\begin{frame}\frametitle{ Deadlocks}

\begin{block}{ Processos bloqueados}
  Essa situação que um processo bloqueia outro por erro nos semáforos buffer é chamada de \textbf{Deadlock}
\end{block}

\pause
\begin{alertblock}{ }
	Esse problema foi levantado para mostrar o cuidado que se deve ter com os semáforos
\end{alertblock}


\end{frame}


%+++++++++++++++++++++++++++++++++++++++++++++++
\section{ Semáforos}
\subsection*{ Monitores}
\begin{frame}\frametitle{ Para facilitar a escrita correta}

\begin{block}{ Uma sincronização de alto nível }
  Um monitor é uma coleção de procedimentos, variáveis e estruturas de dados, tudo isso agrupado em um tipo especial de módulo ou pacote.
\end{block}

\pause
\begin{exampleblock}{ Como funciona?}
	Os processo podem chamar os procedimentos em um monitor quando quiserem, mas não podem ter acesso direto às estruturas internas de dados ao monitor a partir de procedimentos declarados fora do monitor.
\end{exampleblock}

\pause
\begin{alertblock}{ Propriedades dos monitores}
	Somente um processo pode estar ativo em um monitor em um dado momento.
\end{alertblock}

\end{frame}


%------------------------------------------------
\defverbatim[colored]\lstDsp{
\begin{lstlisting}[language=C++,basicstyle=\ttfamily\small,keywordstyle=\color{blue},stringstyle=\color{verde},commentstyle=\color{red}, 
  extendedchars=true,showspaces=false,showstringspaces=false,numbers=left,numberstyle=\tiny,breaklines=true,backgroundcolor=\color{green!10},
  breakautoindent=true,captionpos=b,xleftmargin=0pt]
monitor exemplo
integer i;
condition c;
procedure produtor();
  .
  .
  .
  end;
procedure consumidor();
  .
  .
  .
  end;
end monitor;
\end{lstlisting}
}

\begin{frame}{ Thread Despachante}{C,C++}
\lstDsp
\end{frame}


%------------------------------------------------------------
\begin{frame}\frametitle{ Implementação}

\begin{alertblock}{ Quem é o responsável pela implementação?}
  Cabe ao compilador implementar a exclusão mutua nas entradas do monitor, mas um modo comum é utilizar um \textbf{mutex} ou um semáforo binário.
\end{alertblock}

\pause
\begin{exampleblock}{ Exemplos fáceis}
	Embora monitores representem um modo fácil de fazer exclusão mútua, isso não é o bastante. É preciso também uma maneira de bloquear processos quando não tiverem uma forma de continuar.
\end{exampleblock}

\pause
\begin{block}{ Variáveis condicionais}
	A solução está na introdução de \textbf{variáveis condicionais}, duas operações sobre elas, \textit{wait} e \textit{signal}.
\end{block}

\end{frame}


%------------------------------------------------------------
\begin{frame}\frametitle{ Produtor e consumidor de novo ??}

\begin{block}{ Produtor}
	Quando um procedimento do monitor descobre que não pode prosseguir
\end{block}

\pause
\begin{exampleblock}{ Buffer}
	O produtor descobre que o buffer esta cheio, emite um \textit{wait} sobre alguma variável condicional -- por exemplo a \textbf{full}
\end{exampleblock}

\pause
\begin{block}{ Ação}
	Essa açao resulta no bloqueio do sinal que esta chamando. Ela tambem permite que o outro processo anteriomente proibido de entrar no monitor agora entre
\end{block}

\end{frame}


%------------------------------------------------------------------
\begin{frame}\frametitle{ Produtor e consumidor de novo ??}

\begin{block}{ Consumidor}
	Esse outro processo -- o consumidor -- pode acordar seu parceiro adormecido a partir de um \textbf{signal} para a variavel condicional que seu parceiro esta esperando.
\end{block}

\pause
\begin{exampleblock}{ Buffer}
	O produtor descobre que o buffer esta cheio, emite um \textit{wait} sobre alguma variável condicional -- por exemplo a \textbf{full}
\end{exampleblock}
\end{frame}


%------------------------------------------------
\defverbatim[colored]\lstDsp{
\begin{lstlisting}[language=Pascal,basicstyle=\ttfamily\small,keywordstyle=\color{blue},stringstyle=\color{verde},commentstyle=\color{red}, 
  extendedchars=true,showspaces=false,showstringspaces=false,numbers=left,numberstyle=\tiny,breaklines=true,backgroundcolor=\color{green!10},
  breakautoindent=true,captionpos=b,xleftmargin=0pt]
monitor ProdutorConsumidor
integer count;
condition full, empty;
procedure insere(item: integer);
  begin
  	if count = N then wait(full);
  	insereItem(item);
  	count := count + 1;
  	if count = 1 then signal(empty)
  end;
function remove: integer;
  begin
  	if count = 0 then wait(empty);
  	remove = removeItem;
  	count := count - 1;
  	if count = N - 1 then signal(full)
  end;  count := 0; end monitor;

\end{lstlisting}
}

\begin{frame}{ Produtor -- consumidor}{em Pascal}
\lstDsp
\end{frame}


%------------------------------------------------
\defverbatim[colored]\lstDsp{
\begin{lstlisting}[language=Pascal,basicstyle=\ttfamily\small,keywordstyle=\color{blue},stringstyle=\color{verde},commentstyle=\color{red}, 
  extendedchars=true,showspaces=false,showstringspaces=false,numbers=left,numberstyle=\tiny,breaklines=true,backgroundcolor=\color{green!10},
  breakautoindent=true,captionpos=b,xleftmargin=0pt]

procedure produtor;
  begin
  	while true do
  	begin
  	  item = produzItem;
  	  ProdutorConsumidor.insert(item)
  	end
  end;
procedure consumidor;
  begin
  	while true do
  	begin
  	  item = ProdutorConsumidor.remove;
  	  consumeItem(item);
  	end
  end;
  
\end{lstlisting}
}

\begin{frame}{ Produtor -- consumidor}{em Pascal}
\lstDsp
\end{frame}

\end{document}